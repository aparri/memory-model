"Linux kernel memory model"

(*
 * Copyright (C) 2017 Alan Stern <stern@rowland.harvard.edu>,
 *                    Andrea Parri <parri.andrea@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, you can access it online at
 * http://www.gnu.org/licenses/gpl-2.0.html.
 *)

(* File "lock.cat" handles locks and is experimental.
   It can be replaced by include "cos.cat" for tests that do not use locks *)

include "lock.cat"

(*******************)
(* Basic relations *)
(*******************)

(* Fences *)
let ghost-read = ([M] ; po ; [Ghostacq]) | ([Ghostacq] ; po ; [M])
let ghost-write = ([M] ; po ; [Ghostrel]) | ([Ghostrel] ; po ; [M])
let ghost-before = ([Ghostacq] ; po ; [M]) | ([Ghostrel] ; po ; [M])
let ghost-after = ([M] ; po ; [Ghostacq]) | ([M] ; po ; [Ghostrel])
let ghost-access = ghost-read | ghost-write
let gb-mb = ([M] ; fencerel(Gbmb) ; [M])
let mb = ((([M] ; fencerel(Mb) ; [M]) |
	([M] ; fencerel(Before_atomic) ; [RMW] ; po? ; [M]) |
	([M] ; po? ; [RMW] ; fencerel(After_atomic) ; [M])) \ ghost-access) |
	gb-mb
let rb-dep = ([R] ; fencerel(Rb_dep) ; [R]) \ ghost-read
let rmb = ([R \ Noreturn] ; fencerel(Rmb) ; [R \ Noreturn]) \ ghost-read
let wmb = ([W] ; fencerel(Wmb) ; [W]) \ ghost-write
let gp = po ; [Sync] ; po?

let strong-fence = mb | gp

(* Release Acquire *)
let acq-po = ([Acquire] ; po ; [M]) \ ghost-after
let po-rel = ([M] ; po ; [Release]) \ ghost-before
let rfi-rel-acq = [Release] ; rfi ; [Acquire]

(**********************************)
(* Fundamental coherence ordering *)
(**********************************)

(* Sequential Consistency Per Variable *)
let com = rf | co | fr
acyclic po-loc | com as coherence

(* Atomic Read-Modify-Write *)
empty rmw & (fre ; coe) as atomic

(**********************************)
(* Instruction execution ordering *)
(**********************************)

(* Preserved Program Order *)
let dep = addr | data
let rwdep = (dep | ctrl) ; [W] (* No HW speculates dependent writes... *)
let overwrite = co | fr (* ...fences can expose w-w and w-r orderings... *)
let to-w = rwdep | (overwrite & int) (* ... and per-thread per-location SC *)
let rrdep = addr | (dep ; rfi) (* Ordered, but "addr ; [R]" and DEC Alpha *)
let strong-rrdep = rrdep+ & rb-dep (* DEC Alpha and load-to-load deps ... *)
let to-r = strong-rrdep | rfi-rel-acq (* ... and intra-thread rel-acq *)
let fence = strong-fence | wmb | po-rel | rmb | acq-po (* Non-dep ordering *)
let ppo = rrdep* ; (to-r | to-w | fence) (* Intra-thread ordering *)

(* Propagation: Ordering from release operations and strong fences. *)
let A-cumul(r) = rfe? ; r
let cumul-fence = A-cumul(strong-fence | po-rel) | wmb
let prop = (overwrite & ext)? ; cumul-fence* ; rfe?

(* Happens Before: Ordering from the passage of time. *)
(* No fences needed here for prop because relation confined to one process. *)
let hb = ppo | rfe | ((prop \ id) & int)
acyclic hb as happens-before

(****************************************)
(* Write and fence propagation ordering *)
(****************************************)

(* Propagation: Each non-rf link needs a strong fence. *)
let pb = prop ; strong-fence ; hb*
acyclic pb as propagation

(*******)
(* RCU *)
(*******)

(* Effect of read-side critical section proceeds from the rcu_read_lock() *)
(* onward on the one hand and from the rcu_read_unlock() backwards on the *)
(* other hand.                                                            *)
let rscs = po ; crit^-1 ; po?

(* The synchronize_rcu() strong fence is special in that it can order not *)
(* one but two non-rf relations, but only in conjunction with an RCU      *)
(* read-side critical section.                                            *)
let link = hb* ; pb* ; prop

(* Chains that affect the RCU grace-period guarantee *)
let gp-link = gp ; link
let rscs-link = rscs ; link

(* A cycle containing at least as many grace periods as RCU read-side     *)
(* critical sections is forbidden.                                        *)
let rec rcu-path =
	gp-link |
	(gp-link ; rscs-link) |
	(rscs-link ; gp-link) |
	(rcu-path ; rcu-path) |
	(gp-link ; rcu-path ; rscs-link) |
	(rscs-link ; rcu-path ; gp-link)

irreflexive rcu-path as rcu
